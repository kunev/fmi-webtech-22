### ООП

За разлика от повечето други езици обектно ориентираното програмиране в
javascript не се базира на класове, а на прототипи.

#### С класове
При ООП базирано на класове идеята е, че класовете и обектите имат следните
различни отговорности:
- класът дефинира методи, описващи определено поведение и евентуално общата
  структура на данните във всяка инстанция на класа (атрибутите на инстанциите и
  техните типове).
- обектите инстанции на един клас имат вътрешна структура според описаната
  такава в класа и методите дефинирани в класа могат да бъдат изпълнявани върху
  тези инстанции.

Казано на кратко: класът дефинира поведение (в някои езици и структура), а
обектите държат в себе си данни, върху които оперира въпросното поведение.

#### С прототипи
При ООП базирано на прототипи, вместо обектите, който ползваме да са инстанции
на класове, имат обект прототип (или шаблон), който определя поведението им,
докато всеки от тях носи собствени данни. Отново има разделение между това къде
„живеят“ данните и поведението, но в случая това са различни по роля обекти.

##### Функции конструктори
Всяка функция в javascript има достъп по променлива `this`, която е текущия
обект „върху“ който функцията се изпълнява.
Една функция може да бъде извикана като конструктор с ключовата дума `new`.
Пример за такава функция е `Person` в `oop-1.js`. Добавянето на `new` пред
извикването на функцията означава, че ще се създаде нов обект, върху който тя ще
се изпълни и този обект ще се върне като резултат от целия израз. Забележете, че
ако гледаме на `Person` като на обикновена функция, то тя не връща резултат. В
същото време `let pesho = new Person("Pesho")` води до това променливата `pesho`
да сочи към нов обект, върху който е извикана нашата функция (той има един
атрибут `name`, чиято стойност е `"Pesho"`).

##### prototype
Всяка функция, която дефинираме има **атрибут** `prototype`. Обектите създадени
използвайки тази функция като конструктор имат атрибут `__proto__`, който сочи
към съответния `prototype` на конструктора.

Когато опитваме да достъпим атрибут на някой обект, ако този атрибут не бъде
открит в самия обект, то той се търси в прототипа му. Ако този атрибут е
функция, то при извикването ѝ тя ще вижда текущия обект, през който е извикана
като `this`.


#### Един грешен пример

В `oop-2.js` може да видите пример за нещо, което може да срещнете "out in the
wild", но е всъщност доста лоша практика. Проблемът на това да се закачат методи
директно към обектите, които създаваме в конструктор отново се свежда до липса
на разграничение между данни и поведение. Отделно това ще създаде по един
function обект за всеки нов обект, който създаваме, което води до нужда от много
повече памет, в която просто стоят напълно идентични функции.


#### ES6
В ECMAScript6 (версия 6 на стандарта на javascript) се въвежда и ключовата дума
`class`. В `oop-3.js` има пример за това как се използва. В „тялото“ на една
`class` дефиниция се изреждат методите, които искаме да има нашия „клас“.
Методът с име `constructor` е специален, тъй като той ще се извиква при
създаване на нов обект.

Ключовата дума `class` привидно предоставя достъп до нов "тип" конструкции. В
REPL (ако пуснете `node` в терминала си, или гледате конзолата в браузъра), ще
видите, че името `Person` от `oop-3.js` се оценява като `[class Person]`. В
примера от `oop-1.js` `Person` се оценяваше като `[function Person]`.

Ако си поиграете с `Person` от `oop-3.js` ще видите, че до голяма степен
механизма на реализирането му е сходен с този на конструктор функцията от
`oop-1.js`:
- `Person.prototype` е прототипен обект, от който се създават инстанциите на
  `Person`.
- `Person.prototype.sayHi` е мястото, на което ще намерите функцията, която е
  дефинирана в тялото на класа `Person`.
- `Person.prototype` дори си има `constructor` метод, който е конструктора,
  който сме дефинирали в класа.

Причината за това е, че `class` в ES6 е синтактична захар целяща да даде
по-познат начин за писане на обектно ориентиран код в javascript, която в крайна
сметка води до същите конструкции като в `oop-1.js`. Повечето по-нов код, който
ще видите и/или пишете по-скоро ще използва `class` когато имате нужда от ООП.
Полезно е обаче да имате предвид, че реализацията на всичко отдолу продължава да
е прототипно базирана.

##### Наследяване
Една от основните ползи на обектно ориентираното програмиране е възможността за
наследяване. Може да видите примери за наследяване в ES5 и ES6 в хранилището с
материали на Група А: [тук](https://github.com/dndonev/fmi-webtech-2022/blob/main/week%205/3.%20inheritance-es5.js) и [тук](https://github.com/dndonev/fmi-webtech-2022/blob/main/week%205/4.%20inheritance-es6.js).

`Object.create(obj)` връща нов обект, чиито прототип е подадения аргумент, в
случая `obj`. Ако изпълните примера за наследяване в ES6 може да видите, че
`Student.prototype` е `Person` обект, `Student.prototype.__proto__` е
`Person.prototype`. И тъй като при достъпване на атрибут на обект ако не бъде
намерен в обекта, той се търси в прототипа му `Student.prototype.introduce` е
същия `function` обект като `Person.prototype.introduce`, т.е. всички `Student`
обекти споделят имплементацията на `introduce` с `Person`.
